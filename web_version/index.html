<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe with AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .cell { width: 100%; padding-bottom: 100%; position: relative; transition: background-color 0.3s ease; }
        .cell-content { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 3rem; transition: opacity 0.4s ease; }
        .cell-content.x { color: #38bdf8; }
        .cell-content.o { color: #fb923c; }
        .cell-content.next-to-remove { opacity: 0.5; }
        .hidden { display: none; }
        .mode-button.selected { background-color: #0ea5e9; }
        @media (min-width: 640px) { .cell-content { font-size: 4.5rem; } }
    </style>
</head>
<body class="bg-slate-900 text-white flex items-center justify-center min-h-screen p-4">
    <main class="w-full max-w-md mx-auto text-center">
        <h1 class="text-4xl md:text-5xl font-bold mb-2 text-slate-200">TacTic-Toe</h1>
        <p class="text-slate-400 mb-4">Tactical tictactoe (3-Mark Limit)</p>
        
        <div id="game-mode-selection" class="mb-6">
            <h3 class="text-lg text-slate-300 mb-3">Choose your opponent:</h3>
            <div class="flex justify-center gap-4">
                <button id="pvp-button" class="mode-button bg-sky-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-700 transition-all">Player vs Player</button>
                <button id="pva-button" class="mode-button bg-sky-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-700 transition-all">Player vs AI</button>
            </div>
        </div>

        <div id="player-symbol-selection" class="hidden mb-6">
            <h3 class="text-lg text-slate-300 mb-3">Choose your mark:</h3>
            <div class="flex justify-center gap-4">
                <button id="choose-x-button" class="mode-button bg-sky-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-600 transition-all">Play as X</button>
                <button id="choose-o-button" class="mode-button bg-orange-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-orange-600 transition-all">Play as O</button>
            </div>
        </div>

        <div id="game-area" class="hidden">
            <h2 id="status" class="text-xl md:text-2xl font-medium mb-6 h-8 text-slate-400"></h2>
            <section id="game-board" class="grid grid-cols-3 gap-3 bg-slate-800 p-3 rounded-lg shadow-2xl">
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
            </section>
            <button id="restart-button" class="mt-8 bg-rose-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:bg-rose-700 transition-all">Change Mode</button>
        </div>
    </main>

    <script>
        const statusDisplay = document.getElementById('status');
        const gameCells = document.querySelectorAll('.cell');
        const restartButton = document.getElementById('restart-button');
        const gameModeSelection = document.getElementById('game-mode-selection');
        const pvpButton = document.getElementById('pvp-button');
        const pvaButton = document.getElementById('pva-button');
        const gameArea = document.getElementById('game-area');
        const playerSymbolSelection = document.getElementById('player-symbol-selection');
        const chooseXButton = document.getElementById('choose-x-button');
        const chooseOButton = document.getElementById('choose-o-button');

        let gameActive = false;
        let currentPlayer = 'X';
        let gameState = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        let gameMode = 'pvp';
        let humanPlayer = 'X';
        let aiPlayer = 'O';

        const winningConditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], 
            [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]
        ];
        
        const winningMessage = () => `Player ${currentPlayer} has won!`;
        const currentPlayerTurn = () => `Player ${currentPlayer}'s turn`;

        function selectGameMode(mode) {
            gameMode = mode;
            gameModeSelection.classList.add('hidden');
            if (mode === 'pvp') {
                gameArea.classList.remove('hidden');
                startGame();
            } else {
                playerSymbolSelection.classList.remove('hidden');
            }
        }

        function selectPlayerSymbol(symbol) {
            humanPlayer = symbol;
            aiPlayer = symbol === 'X' ? 'O' : 'X';
            playerSymbolSelection.classList.add('hidden');
            gameArea.classList.remove('hidden');
            startGame();
        }

        function startGame() {
            gameActive = true;
            currentPlayer = 'X';
            gameState = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            statusDisplay.innerHTML = currentPlayerTurn();
            updateBoardUI(); // Use a central function to draw the board
            if (gameMode === 'pva' && currentPlayer === aiPlayer) {
                 setTimeout(aiMove, 500);
            }
        }

        function handleRestartGame() {
            gameActive = false;
            gameArea.classList.add('hidden');
            playerSymbolSelection.classList.add('hidden');
            gameModeSelection.classList.remove('hidden');
        }

        function handleCellClick(clickedCellEvent) {
            const clickedCell = clickedCellEvent.currentTarget;
            const clickedCellIndex = Array.from(gameCells).indexOf(clickedCell);
            if (gameState[clickedCellIndex] !== 0 || !gameActive || (gameMode === 'pva' && currentPlayer === aiPlayer)) {
                return;
            }
            makeMove(clickedCellIndex);

            if (gameActive) {
                handlePlayerChange();
            }
        }
        

        function makeMove(index) {
            if (gameState[index] !== 0 || !gameActive) return;

            const isX = currentPlayer === 'X';
            const playerSign = isX ? 1 : -1;
            const freshPieceValue = isX ? 3 : -3;
            const oldestPieceValue = isX ? 1 : -1;

            gameState = gameState.map(cell => {
                if (cell == 0) {
                    return cell;
                }
                else if (isX && cell > 0)
                {
                    return (cell - 1)
                }
                else if (!isX && cell < 0)
                {
                    return (cell + 1)
                }
                return cell
            });

            gameState[index] = freshPieceValue;

            const turn = (currentPlayer === 'X') ? O : X;
            const { key, transform } = getCanonicalForm(gameState, turn);
            const moveData = precomputedMoves[key];
            console.log("State score:" + moveData.score)

            updateBoardUI();
            handleResultValidation();
        }

        /**
         * NEW: Central function to render the gameState to the board.
         */
        function updateBoardUI() {
            gameState.forEach((cellValue, index) => {
                const cellContent = gameCells[index].querySelector('.cell-content');
                cellContent.textContent = '';
                cellContent.className = 'cell-content'; // Reset classes

                if (cellValue > 0) {
                    cellContent.textContent = 'X';
                    cellContent.classList.add('x');
                } else if (cellValue < 0) {
                    cellContent.textContent = 'O';
                    cellContent.classList.add('o');
                }
            });
        }
        
        function handleResultValidation() {
            if (checkWin(gameState, currentPlayer)) {
                statusDisplay.innerHTML = winningMessage();
                gameActive = false;
                updateTransparencyCue(true);
            }
        }

        function handlePlayerChange() {
            currentPlayer = currentPlayer === "X" ? "O" : "X";
            statusDisplay.innerHTML = currentPlayerTurn();
            updateBoardUI(); // Redraw board to apply any visual cues
            updateTransparencyCue();
            if (gameMode === 'pva' && currentPlayer === aiPlayer && gameActive) {
                setTimeout(aiMove, 500);
            }
        }

        function updateTransparencyCue(clearAll = false) {
             // First, clear all existing cues
            gameCells.forEach(cell => {
                cell.querySelector('.cell-content').classList.remove('next-to-remove');
            });
            if (clearAll) return;

            const isX = currentPlayer === 'X';
            const playerSign = isX ? 1 : -1;
            const oldestPieceValue = isX ? 1 : -1;

            let pieceCount = 0;
            for (const cell of gameState) {
                if (Math.sign(cell) === playerSign) pieceCount++;
            }

            // If the current player has 3 pieces, their next move will be a "move".
            if (pieceCount === 3) {
                const oldestPieceIndex = gameState.indexOf(oldestPieceValue);
                if (oldestPieceIndex !== -1) {
                    gameCells[oldestPieceIndex].querySelector('.cell-content').classList.add('next-to-remove');
                }
            }
        }

        // --- AI Logic & State Encoding
        let precomputedMoves = null;

        async function loadPrecomputedMoves() {
            try {
                const response = await fetch('./tactictoe_states.json');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                precomputedMoves = await response.json();
                console.log("AI moves loaded successfully.");
            } catch (error) {
                console.error("Could not load AI moves:", error);
                pvaButton.disabled = true;
                pvaButton.textContent = "AI Unavailable";
                pvaButton.style.backgroundColor = '#475569';
            }
        }
        loadPrecomputedMoves();

        const X = 1;
        const O = -1;

        const TRANSFORMATION_MAPS = [
            [0, 1, 2, 3, 4, 5, 6, 7, 8], [2, 5, 8, 1, 4, 7, 0, 3, 6],
            [8, 7, 6, 5, 4, 3, 2, 1, 0], [6, 3, 0, 7, 4, 1, 8, 5, 2],
            [2, 1, 0, 5, 4, 3, 8, 7, 6], [0, 3, 6, 1, 4, 7, 2, 5, 8],
            [8, 5, 2, 7, 4, 1, 6, 3, 0], [6, 7, 8, 3, 4, 5, 0, 1, 2],
        ];

        function boardToPosition(board_flat) {
            const CELL_MAP = {'-3': 0, '-2': 1, '-1': 2, '1': 3, '2': 4, '3': 5};
            const location_arr = Array(6).fill(0x0F);
            for (let i = 0; i < board_flat.length; i++) {
                const cell = board_flat[i];
                if (cell !== 0) {
                    const pieceId = cell.toString();
                    if (CELL_MAP.hasOwnProperty(pieceId)) {
                       const locationIndex = CELL_MAP[pieceId];
                       location_arr[locationIndex] = i;
                    }
                }
            }
            return location_arr;
        }

        function encodeState(board_flat, turn) {
            const location_arr = boardToPosition(board_flat);
            const byte0 = (location_arr[0] << 4) | location_arr[1];
            const byte1 = (location_arr[2] << 4) | location_arr[3];
            const byte2 = (location_arr[4] << 4) | location_arr[5];
            const byte3 = (turn === X) ? 1 : 0;
            return ((byte0 << 24) | (byte1 << 16) | (byte2 << 8) | byte3) >>> 0;
        }

        function getCanonicalForm(board_flat, turn) {
            let minStateEncoded = encodeState(board_flat, turn);
            let bestTransform = TRANSFORMATION_MAPS[0];
            for (const transform_map of TRANSFORMATION_MAPS) {
                const transformed_board = Array(9).fill(0);
                for(let i = 0; i < 9; i++) {
                    transformed_board[transform_map[i]] = board_flat[i];
                }
                const transformedStateEncoded = encodeState(transformed_board, turn);
                if (transformedStateEncoded < minStateEncoded) {
                    minStateEncoded = transformedStateEncoded;
                    bestTransform = transform_map;
                }
            }
            return { key: minStateEncoded, transform: bestTransform };
        }

        function aiMove() {
            if (!precomputedMoves) return;
            const bestMoveIndex = findBestMoveFromJSON();
            if (bestMoveIndex !== null) {
                makeMove(bestMoveIndex);
                if (gameActive) {
                    handlePlayerChange();
                }
            } else {
                console.error("AI could not determine a valid move.");
                statusDisplay.innerHTML = "AI Error!";
                gameActive = false;
            }
        }

        function findBestMoveFromJSON() {
            const turn = (currentPlayer === 'X') ? X : O;
            const { key, transform } = getCanonicalForm(gameState, turn);
            const moveData = precomputedMoves[key];
            if (!moveData || !moveData.moves || moveData.moves.length === 0) {
                console.error(`No moves found in JSON for canonical key: ${key}. Current gameState: [${gameState}]`);
                return null;
            }
            const bestCanonicalMove = moveData.moves[Math.floor(Math.random() * moveData.moves.length)];
            const [row, col] = bestCanonicalMove;
            const canonicalMoveIndex = row * 3 + col;
            return transform.indexOf(canonicalMoveIndex);
        }

        function checkWin(board, player) {
            const isX = player === 'X';
            for (const condition of winningConditions) {
                const [a, b, c] = condition;
                if (isX) {
                    if (board[a] > 0 && board[b] > 0 && board[c] > 0) return true;
                } else {
                    if (board[a] < 0 && board[b] < 0 && board[c] < 0) return true;
                }
            }
            return false;
        }

        // --- Event Listeners ---
        pvpButton.addEventListener('click', () => selectGameMode('pvp'));
        pvaButton.addEventListener('click', () => selectGameMode('pva'));
        restartButton.addEventListener('click', handleRestartGame);
        gameCells.forEach(cell => cell.addEventListener('click', handleCellClick));
        chooseXButton.addEventListener('click', () => selectPlayerSymbol('X'));
        chooseOButton.addEventListener('click', () => selectPlayerSymbol('O'));
    </script>
</body>
</html>