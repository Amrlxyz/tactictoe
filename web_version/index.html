<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe with AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .cell {
            width: 100%;
            padding-bottom: 100%;
            position: relative;
            transition: background-color 0.3s ease;
        }
        .cell-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            transition: opacity 0.4s ease;
        }
        .cell-content.x { color: #38bdf8; }
        .cell-content.o { color: #fb923c; }
        .cell-content.next-to-remove { opacity: 0.5; }
        .hidden { display: none; }
        .mode-button.selected { background-color: #0ea5e9; }
        @media (min-width: 640px) {
            .cell-content { font-size: 4.5rem; }
        }
    </style>
</head>
<body class="bg-slate-900 text-white flex items-center justify-center min-h-screen p-4">

    <main class="w-full max-w-md mx-auto text-center">
        <h1 class="text-4xl md:text-5xl font-bold mb-2 text-slate-200">Tic-Tac-Toe</h1>
        <p class="text-slate-400 mb-4">3-Mark Limit Edition</p>
        
        <div id="game-mode-selection" class="mb-6">
            <h3 class="text-lg text-slate-300 mb-3">Choose your opponent:</h3>
            <div class="flex justify-center gap-4">
                <button id="pvp-button" class="mode-button bg-sky-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-700 transition-all">Player vs Player</button>
                <button id="pva-button" class="mode-button bg-sky-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-700 transition-all">Player vs AI</button>
            </div>
        </div>

        <div id="player-symbol-selection" class="hidden mb-6">
            <h3 class="text-lg text-slate-300 mb-3">Choose your mark:</h3>
            <div class="flex justify-center gap-4">
                <button id="choose-x-button" class="mode-button bg-sky-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-600 transition-all">Play as X</button>
                <button id="choose-o-button" class="mode-button bg-orange-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-orange-600 transition-all">Play as O</button>
            </div>
        </div>

        <div id="game-area" class="hidden">
            <h2 id="status" class="text-xl md:text-2xl font-medium mb-6 h-8 text-slate-400"></h2>
            <section id="game-board" class="grid grid-cols-3 gap-3 bg-slate-800 p-3 rounded-lg shadow-2xl">
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
            </section>
            <button id="restart-button" class="mt-8 bg-rose-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:bg-rose-700 transition-all">Change Mode</button>
        </div>
    </main>

    <script>
        // --- DOM Elements ---
        const statusDisplay = document.getElementById('status');
        const gameCells = document.querySelectorAll('.cell');
        const restartButton = document.getElementById('restart-button');
        const gameModeSelection = document.getElementById('game-mode-selection');
        const pvpButton = document.getElementById('pvp-button');
        const pvaButton = document.getElementById('pva-button');
        const gameArea = document.getElementById('game-area');
        // --- NEW DOM ELEMENTS ---
        const playerSymbolSelection = document.getElementById('player-symbol-selection');
        const chooseXButton = document.getElementById('choose-x-button');
        const chooseOButton = document.getElementById('choose-o-button');


        // --- Game State Variables ---
        let gameActive = false;
        let currentPlayer = 'X';
        let gameState = ["", "", "", "", "", "", "", "", ""];
        let playerXMoves = [];
        let playerOMoves = [];
        let gameMode = 'pvp'; // 'pvp' or 'pva'
        // --- MODIFIED: Changed from const to let ---
        let humanPlayer = 'X';
        let aiPlayer = 'O';

        // --- Winning Combinations ---
        const winningConditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], 
            [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]
        ];
        
        // --- Messages ---
        const winningMessage = () => `Player ${currentPlayer} has won!`;
        const currentPlayerTurn = () => `Player ${currentPlayer}'s turn`;

        // --- Game Setup Functions ---
        
        // --- This function now handles showing the symbol choice screen ---
        function selectGameMode(mode) {
            gameMode = mode;
            gameModeSelection.classList.add('hidden');
            
            if (mode === 'pvp') {
                gameArea.classList.remove('hidden');
                startGame();
            } else { // 'pva'
                playerSymbolSelection.classList.remove('hidden');
            }
        }

        // --- Handles the player's choice of X or O ---
        function selectPlayerSymbol(symbol) {
            humanPlayer = symbol;
            aiPlayer = symbol === 'X' ? 'O' : 'X';
            
            playerSymbolSelection.classList.add('hidden');
            gameArea.classList.remove('hidden');
            startGame();

            // If human chose 'O', AI ('X') must go first.
            if (currentPlayer === aiPlayer) {
                 setTimeout(aiMove, 500);
            }
        }

        function startGame() {
            gameActive = true;
            currentPlayer = 'X'; // Game always starts with X
            gameState = ["", "", "", "", "", "", "", "", ""];
            playerXMoves = [];
            playerOMoves = [];
            statusDisplay.innerHTML = currentPlayerTurn();
            gameCells.forEach(cell => {
                const cellContent = cell.querySelector('.cell-content');
                cellContent.textContent = "";
                cellContent.classList.remove('x', 'o', 'next-to-remove');
            });
        }

        // --- MODIFIED: Now also hides the new symbol selection screen ---
        function handleRestartGame() {
            gameActive = false;
            gameArea.classList.add('hidden');
            playerSymbolSelection.classList.add('hidden'); // Hide symbol choice on restart
            gameModeSelection.classList.remove('hidden');
        }

        // --- Core Game Logic ---

        function handleCellClick(clickedCellEvent) {
            const clickedCell = clickedCellEvent.currentTarget;
            const clickedCellIndex = Array.from(gameCells).indexOf(clickedCell);

            // Prevent move if cell is taken, game is inactive, or it's AI's turn
            if (gameState[clickedCellIndex] !== "" || !gameActive || (gameMode === 'pva' && currentPlayer === aiPlayer)) {
                return;
            }

            makeMove(clickedCellIndex);

            if (gameActive) {
                handlePlayerChange();
            }
        }

        function makeMove(index) {
            if (gameState[index] !== "" || !gameActive) return;

            // 1. Update state and UI for the new mark
            gameState[index] = currentPlayer;
            const cell = gameCells[index];
            const cellContent = cell.querySelector('.cell-content');
            cellContent.textContent = currentPlayer;
            cellContent.classList.add(currentPlayer.toLowerCase());

            // 2. Add move to the player's history
            const currentMoves = currentPlayer === 'X' ? playerXMoves : playerOMoves;
            currentMoves.push(index);

            // 3. Enforce the 3-mark limit
            if (currentMoves.length > 3) {
                const oldestMoveIndex = currentMoves.shift();
                gameState[oldestMoveIndex] = "";
                const oldestCell = gameCells[oldestMoveIndex];
                const oldestCellContent = oldestCell.querySelector('.cell-content');
                oldestCellContent.textContent = "";
                oldestCellContent.classList.remove('x', 'o');
            }
            
            handleResultValidation();
        }

        function handleResultValidation() {
            let roundWon = checkWin(gameState, currentPlayer);

            if (roundWon) {
                statusDisplay.innerHTML = winningMessage();
                gameActive = false;
                updateTransparencyCue(true);
                return;
            }
        }

        function handlePlayerChange() {
            currentPlayer = currentPlayer === "X" ? "O" : "X";
            statusDisplay.innerHTML = currentPlayerTurn();
            updateTransparencyCue();

            // If it's AI's turn, trigger its move
            if (gameMode === 'pva' && currentPlayer === aiPlayer && gameActive) {
                // Add a small delay for better user experience
                setTimeout(aiMove, 500);
            }
        }

        function updateTransparencyCue(clearAll = false) {
            gameCells.forEach(cell => {
                cell.querySelector('.cell-content').classList.remove('next-to-remove');
            });
            if (clearAll) return;

            const nextPlayerMoves = currentPlayer === 'X' ? playerXMoves : playerOMoves;
            if (nextPlayerMoves.length === 3) {
                const oldestMoveIndex = nextPlayerMoves[0];
                gameCells[oldestMoveIndex].querySelector('.cell-content').classList.add('next-to-remove');
            }
        }

        // --- NEW: AI Move Lookup Table ---
        let precomputedMoves = null;

        // Function to load the JSON data
        async function loadPrecomputedMoves() {
            try {
                const response = await fetch('./tactictoe_states.json'); // Assumes moves.json is in the same folder
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                precomputedMoves = await response.json();
                console.log("AI moves loaded successfully.");
                // You could enable the AI button here if it was initially disabled
            } catch (error) {
                console.error("Could not load AI moves:", error);
                // Maybe disable the Player vs AI button if data fails to load
                pvaButton.disabled = true;
                pvaButton.textContent = "AI Unavailable";
                pvaButton.style.backgroundColor = '#475569'; // slate-600
            }
        }

        // --- Call the function to load data when the script starts ---
        loadPrecomputedMoves();

        // --- NEW: JavaScript implementation of your Python functions ---

        // Player constants (assuming X is 1, O is -1, as often used in AI)
        const X = 1;
        const O = -1;

        // The 8 symmetries of the Tic-Tac-Toe board
        const TRANSFORMATION_MAPS = [
            [0, 1, 2, 3, 4, 5, 6, 7, 8], // Identity
            [2, 5, 8, 1, 4, 7, 0, 3, 6], // Rotate 90
            [8, 7, 6, 5, 4, 3, 2, 1, 0], // Rotate 180
            [6, 3, 0, 7, 4, 1, 8, 5, 2], // Rotate 270
            [2, 1, 0, 5, 4, 3, 8, 7, 6], // Flip horizontal
            [0, 3, 6, 1, 4, 7, 2, 5, 8], // Flip along y=x axis
            [8, 5, 2, 7, 4, 1, 6, 3, 0], // Flip along y=-x axis
            [6, 7, 8, 3, 4, 5, 0, 1, 2], // Flip vertical
        ];

        /**
         * Creates an array of piece locations for encoding.
         * The first 3 positions are for player X, the next 3 for player O.
         * Uses 0x0F (15) as a sentinel value for an unused piece slot.
         * @param {string[]} playerXMoves - Array of indices for X's pieces.
         * @param {string[]} playerOMoves - Array of indices for O's pieces.
         * @returns {number[]} - A 6-element array of piece locations.
         */
        function boardToPosition(playerXMoves, playerOMoves) {
            const x_pos = [...playerXMoves];
            const o_pos = [...playerOMoves];

            // Pad with sentinel value if player has fewer than 3 pieces
            while (x_pos.length < 3) x_pos.push(0x0F);
            while (o_pos.length < 3) o_pos.push(0x0F);
            
            // The spec implies X's pieces followed by O's pieces
            return [...x_pos, ...o_pos];
        }

        /**
         * Encodes the board state and turn into a single 32-bit integer key.
         * This matches the format of the keys in your Python-generated JSON.
         * @param {number[]} playerXMoves - The indices of X's pieces.
         * @param {number[]} playerOMoves - The indices of O's pieces.
         * @param {number} turn - The current player (1 for X, -1 for O).
         * @returns {number} The integer key representing the game state.
         */
        function encodeState(playerXMoves, playerOMoves, turn) {
            const location_arr = boardToPosition(playerXMoves, playerOMoves);

            const byte0 = (location_arr[0] << 4) | location_arr[1];
            const byte1 = (location_arr[2] << 4) | location_arr[3];
            const byte2 = (location_arr[4] << 4) | location_arr[5];
            const byte3 = (turn === X) ? 1 : 0;

            // Combine the 4 bytes into a single 32-bit integer
            // Note: JavaScript bitwise operations are on signed 32-bit integers.
            // The `>>> 0` at the end ensures the result is treated as an unsigned integer,
            // which prevents issues with the sign bit if the first byte is > 127.
            return ((byte0 << 24) | (byte1 << 16) | (byte2 << 8) | byte3) >>> 0;
        }

        /**
         * Decodes a 32-bit integer key back into a game state object.
         * Useful for debugging and verification.
         * @param {number} encoded_state - The integer key.
         * @returns {object} An object containing the board, moves, and turn.
         */
        function decodeState(encoded_state) {
            const byte0 = (encoded_state >> 24) & 0xFF;
            const byte1 = (encoded_state >> 16) & 0xFF;
            const byte2 = (encoded_state >> 8) & 0xFF;
            const byte3 = encoded_state & 0xFF;

            const turn = (byte3 & 0x01) === 1 ? X : O;

            const location_arr = [
                byte0 >> 4,
                byte0 & 0x0F,
                byte1 >> 4,
                byte1 & 0x0F,
                byte2 >> 4,
                byte2 & 0x0F,
            ];

            const playerXMoves = location_arr.slice(0, 3).filter(loc => loc !== 0x0F);
            const playerOMoves = location_arr.slice(3, 6).filter(loc => loc !== 0x0F);

            const board_flat = Array(9).fill("");
            playerXMoves.forEach(idx => board_flat[idx] = 'X');
            playerOMoves.forEach(idx => board_flat[idx] = 'O');

            return {
                board: board_flat,
                playerXMoves,
                playerOMoves,
                turn: turn === X ? 'X' : 'O',
            };
        }


        /**
         * Finds the canonical representation of a board state by checking all 8 symmetries.
         * This ensures that rotated or flipped boards map to the same key.
         * @param {string[]} board_flat - The 9-element array representing the board.
         * @param {number[]} playerXMoves - Current X moves.
         * @param {number[]} playerOMoves - Current O moves.
         * @param {number} turn - The current player (1 or -1).
         * @returns {number} The smallest integer key representing the canonical form.
         */
        function getCanonicalForm(board_flat, playerXMoves, playerOMoves, turn) {
            let minStateEncoded = encodeState(playerXMoves, playerOMoves, turn);

            for (const transform_map of TRANSFORMATION_MAPS) {
                // Create new move arrays based on the transformation map
                const transformedXMoves = playerXMoves.map(pos => transform_map.indexOf(pos)).sort((a,b) => a-b);
                const transformedOMoves = playerOMoves.map(pos => transform_map.indexOf(pos)).sort((a,b) => a-b);

                const transformedStateEncoded = encodeState(transformedXMoves, transformedOMoves, turn);
                
                if (transformedStateEncoded < minStateEncoded) {
                    minStateEncoded = transformedStateEncoded;
                }
            }

            return minStateEncoded;
        }

        // --- AI Logic (Lookup Table) ---

        function aiMove() {
            // Check if the precomputed moves have been loaded
            if (!precomputedMoves) {
                console.log("AI is thinking... (or data is still loading)");
                statusDisplay.innerHTML = "AI data loading...";
                return;
            }

            // findBestMoveFromJSON now returns a [from, to] array or null
            const bestMoveArray = findBestMoveFromJSON(); 
            
            if (bestMoveArray) {
                const [from, to] = bestMoveArray;
                
                // The existing makeMove function works perfectly, as it only needs
                // the destination index ('to') to place the piece. It will
                // automatically handle removing the oldest piece if necessary.
                makeMove(to);

                if (gameActive) {
                    handlePlayerChange();
                }
            } else {
                console.error("AI could not determine a valid move!");
                statusDisplay.innerHTML = "AI is confused!";
                gameActive = false;
            }
        }

        /**
         * NEW HELPER FUNCTION
         * Generates all possible moves for a player from the current state.
         * A move is represented as a [from, to] pair.
         * For placements, 'from' is -1.
         * @param {number[]} playerMoves - The list of current piece positions for the player.
         * @param {string[]} boardState - The 9-element array of the board.
         * @returns {number[][]} An array of possible moves, e.g., [[-1, 0], [2, 5]].
         */
        function getAvailableMoves(playerMoves, boardState) {
            const availableMoves = [];
            const emptyCells = [];
            boardState.forEach((cell, index) => {
                if (cell === "") {
                    emptyCells.push(index);
                }
            });

            if (playerMoves.length < 3) {
                // Placement moves: from a non-existent spot (-1) to an empty cell.
                emptyCells.forEach(to => {
                    availableMoves.push([-1, to]);
                });
            } else {
                // Moving pieces: from an existing piece to an empty cell.
                playerMoves.forEach(from => {
                    emptyCells.forEach(to => {
                        availableMoves.push([from, to]);
                    });
                });
            }
            return availableMoves;
        }

        /**
         * NEW HELPER FUNCTION
         * Simulates a move on a given state and returns the new state without
         * modifying the original. Used for checking outcomes.
         * @param {object} state - The current state { gameState, playerXMoves, playerOMoves }.
         * @param {number[]} move - The move to simulate [from, to].
         * @param {string} player - The player making the move ('X' or 'O').
         * @returns {object} The new state after the move { newGameState, newPlayerXMoves, newPlayerOMoves }.
         */
        function simulateMove(state, move, player) {
            const [from, to] = move;
            
            // Create copies to avoid mutating the original state
            const newGameState = [...state.gameState];
            let newPlayerXMoves = [...state.playerXMoves];
            let newPlayerOMoves = [...state.playerOMoves];

            // Place the new piece
            newGameState[to] = player;
            
            // Remove the old piece if it was a move (not a placement)
            if (from !== -1) {
                newGameState[from] = "";
            }

            // Update the correct player's move list
            if (player === 'X') {
                newPlayerXMoves.push(to);
                if (from !== -1) {
                    newPlayerXMoves = newPlayerXMoves.filter(pos => pos !== from);
                } else if (newPlayerXMoves.length > 3) {
                    const oldestMove = newPlayerXMoves.shift();
                    newGameState[oldestMove] = "";
                }
            } else { // Player is 'O'
                newPlayerOMoves.push(to);
                if (from !== -1) {
                    newPlayerOMoves = newPlayerOMoves.filter(pos => pos !== from);
                } else if (newPlayerOMoves.length > 3) {
                    const oldestMove = newPlayerOMoves.shift();
                    newGameState[oldestMove] = "";
                }
            }
            
            return { newGameState, newPlayerXMoves, newPlayerOMoves };
        }

        function findBestMoveFromJSON() {
            // 1. Get the canonical key for the current (original) state.
            const turn = (currentPlayer === 'X') ? X : O;
            const canonicalKey = getCanonicalForm(gameState, playerXMoves, playerOMoves, turn);

            const canonicalMoveData = precomputedMoves[canonicalKey];
            if (!canonicalMoveData || canonicalMoveData.moves.length === 0) {
                console.error("No moves found for canonical key:", canonicalKey);
                return null; // Return null if no move is found
            }

            // 2. Get the best canonical move and the resulting target canonical state.
            // Randomly choose one of the best moves from the JSON data.
            const bestCanonicalMove = canonicalMoveData.moves[Math.floor(Math.random() * canonicalMoveData.moves.length)];
            const canonicalStateDecoded = decodeState(canonicalKey);
            const nextPlayer = turn === X ? O : X;
            
            const targetStateAfterMove = simulateMove(
                { gameState: canonicalStateDecoded.board, playerXMoves: canonicalStateDecoded.playerXMoves, playerOMoves: canonicalStateDecoded.playerOMoves },
                bestCanonicalMove,
                turn === X ? 'X' : 'O'
            );
            
            const targetCanonicalKey = getCanonicalForm(
                targetStateAfterMove.newGameState,
                targetStateAfterMove.newPlayerXMoves,
                targetStateAfterMove.newPlayerOMoves,
                nextPlayer
            );

            // 3. Get all available moves in the original state.
            const currentPlayerMoves = (currentPlayer === 'X') ? playerXMoves : playerOMoves;
            const availableMoves = getAvailableMoves(currentPlayerMoves, gameState);
            
            // 4. Find which of the original moves result in the target canonical state.
            const validBestMoves = [];
            for (const move of availableMoves) {
                const resultingState = simulateMove({ gameState, playerXMoves, playerOMoves }, move, currentPlayer);
                
                const resultingKey = getCanonicalForm(
                    resultingState.newGameState,
                    resultingState.newPlayerXMoves,
                    resultingState.newPlayerOMoves,
                    nextPlayer
                );

                if (resultingKey === targetCanonicalKey) {
                    validBestMoves.push(move);
                }
            }

            // 5. Choose one of the potential moves randomly.
            if (validBestMoves.length > 0) {
                return validBestMoves[Math.floor(Math.random() * validBestMoves.length)];
            }

            console.error("Could not find a valid original move that maps to the canonical best move.");
            return null; // Fallback
        }

        function checkWin(board, player) {
            for (let i = 0; i < winningConditions.length; i++) {
                const [a, b, c] = winningConditions[i];
                if (board[a] === player && board[b] === player && board[c] === player) {
                    return true;
                }
            }
            return false;
        }

        // --- Event Listeners ---
        pvpButton.addEventListener('click', () => selectGameMode('pvp'));
        pvaButton.addEventListener('click', () => selectGameMode('pva'));
        restartButton.addEventListener('click', handleRestartGame);
        gameCells.forEach(cell => cell.addEventListener('click', handleCellClick));
        // --- NEW EVENT LISTENERS ---
        chooseXButton.addEventListener('click', () => selectPlayerSymbol('X'));
        chooseOButton.addEventListener('click', () => selectPlayerSymbol('O'));

    </script>
</body>
</html>