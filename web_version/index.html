<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe with AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .cell {
            width: 100%;
            padding-bottom: 100%;
            position: relative;
            transition: background-color 0.3s ease;
        }
        .cell-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            transition: opacity 0.4s ease;
        }
        .cell-content.x { color: #38bdf8; }
        .cell-content.o { color: #fb923c; }
        .cell-content.next-to-remove { opacity: 0.5; }
        .hidden { display: none; }
        .mode-button.selected { background-color: #0ea5e9; }
        @media (min-width: 640px) {
            .cell-content { font-size: 4.5rem; }
        }
    </style>
</head>
<body class="bg-slate-900 text-white flex items-center justify-center min-h-screen p-4">

    <main class="w-full max-w-md mx-auto text-center">
        <h1 class="text-4xl md:text-5xl font-bold mb-2 text-slate-200">Tic-Tac-Toe</h1>
        <p class="text-slate-400 mb-4">3-Mark Limit Edition</p>
        
        <div id="game-mode-selection" class="mb-6">
            <h3 class="text-lg text-slate-300 mb-3">Choose your opponent:</h3>
            <div class="flex justify-center gap-4">
                <button id="pvp-button" class="mode-button bg-sky-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-700 transition-all">Player vs Player</button>
                <button id="pva-button" class="mode-button bg-sky-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-700 transition-all">Player vs AI</button>
            </div>
        </div>

        <div id="player-symbol-selection" class="hidden mb-6">
            <h3 class="text-lg text-slate-300 mb-3">Choose your mark:</h3>
            <div class="flex justify-center gap-4">
                <button id="choose-x-button" class="mode-button bg-sky-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-600 transition-all">Play as X</button>
                <button id="choose-o-button" class="mode-button bg-orange-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-orange-600 transition-all">Play as O</button>
            </div>
        </div>

        <div id="game-area" class="hidden">
            <h2 id="status" class="text-xl md:text-2xl font-medium mb-6 h-8 text-slate-400"></h2>
            <section id="game-board" class="grid grid-cols-3 gap-3 bg-slate-800 p-3 rounded-lg shadow-2xl">
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
            </section>
            <button id="restart-button" class="mt-8 bg-rose-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:bg-rose-700 transition-all">Change Mode</button>
        </div>
    </main>

    <script>
        // --- DOM Elements ---
        const statusDisplay = document.getElementById('status');
        const gameCells = document.querySelectorAll('.cell');
        const restartButton = document.getElementById('restart-button');
        const gameModeSelection = document.getElementById('game-mode-selection');
        const pvpButton = document.getElementById('pvp-button');
        const pvaButton = document.getElementById('pva-button');
        const gameArea = document.getElementById('game-area');
        // --- NEW DOM ELEMENTS ---
        const playerSymbolSelection = document.getElementById('player-symbol-selection');
        const chooseXButton = document.getElementById('choose-x-button');
        const chooseOButton = document.getElementById('choose-o-button');


        // --- Game State Variables ---
        let gameActive = false;
        let currentPlayer = 'X';
        let gameState = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        let playerXMoves = [];
        let playerOMoves = [];
        let gameMode = 'pvp'; // 'pvp' or 'pva'
        // --- MODIFIED: Changed from const to let ---
        let humanPlayer = 'X';
        let aiPlayer = 'O';

        // --- Winning Combinations ---
        const winningConditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], 
            [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]
        ];
        
        // --- Messages ---
        const winningMessage = () => `Player ${currentPlayer} has won!`;
        const currentPlayerTurn = () => `Player ${currentPlayer}'s turn`;

        // --- Game Setup Functions ---
        
        // --- This function now handles showing the symbol choice screen ---
        function selectGameMode(mode) {
            gameMode = mode;
            gameModeSelection.classList.add('hidden');
            
            if (mode === 'pvp') {
                gameArea.classList.remove('hidden');
                startGame();
            } else { // 'pva'
                playerSymbolSelection.classList.remove('hidden');
            }
        }

        // --- Handles the player's choice of X or O ---
        function selectPlayerSymbol(symbol) {
            humanPlayer = symbol;
            aiPlayer = symbol === 'X' ? 'O' : 'X';
            
            playerSymbolSelection.classList.add('hidden');
            gameArea.classList.remove('hidden');
            startGame();

            // If human chose 'O', AI ('X') must go first.
            if (currentPlayer === aiPlayer) {
                 setTimeout(aiMove, 500);
            }
        }

        function startGame() {
            gameActive = true;
            currentPlayer = 'X';
            // Initialize with 0 for empty cells
            gameState = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            playerXMoves = [];
            playerOMoves = [];
            statusDisplay.innerHTML = currentPlayerTurn();
            gameCells.forEach(cell => {
                const cellContent = cell.querySelector('.cell-content');
                cellContent.textContent = "";
                cellContent.classList.remove('x', 'o', 'next-to-remove');
            });
        }

        // --- MODIFIED: Now also hides the new symbol selection screen ---
        function handleRestartGame() {
            gameActive = false;
            gameArea.classList.add('hidden');
            playerSymbolSelection.classList.add('hidden'); // Hide symbol choice on restart
            gameModeSelection.classList.remove('hidden');
        }

        // --- Core Game Logic ---

        function handleCellClick(clickedCellEvent) {
            const clickedCell = clickedCellEvent.currentTarget;
            const clickedCellIndex = Array.from(gameCells).indexOf(clickedCell);

            // Prevent move if cell is taken (not 0), game is inactive, or it's AI's turn
            if (gameState[clickedCellIndex] !== 0 || !gameActive || (gameMode === 'pva' && currentPlayer === aiPlayer)) {
                return;
            }

            makeMove(clickedCellIndex);

            if (gameActive) {
                handlePlayerChange();
            }
        }


        function makeMove(index) {
            if (gameState[index] !== 0 || !gameActive) return;

            const isX = currentPlayer === 'X';
            const currentMoves = isX ? playerXMoves : playerOMoves;
            
            // 1. Determine the unique piece ID to place based on the new rule.
            let pieceToPlace;
            const moveCount = currentMoves.length;
            if (isX) {
                // X starts with 3 and counts down (3, 2, 1)
                pieceToPlace = 3 - moveCount;
            } else {
                // O starts with -3 and counts up (-3, -2, -1)
                pieceToPlace = -3 + moveCount;
            }

            // 2. Update state with the new unique piece
            gameState[index] = pieceToPlace;
            currentMoves.push(pieceToPlace);

            // 3. Update the UI to show 'X' or 'O'
            const cell = gameCells[index];
            const cellContent = cell.querySelector('.cell-content');
            cellContent.textContent = currentPlayer;
            cellContent.classList.add(currentPlayer.toLowerCase());

            // 4. Enforce the 3-mark limit by removing the OLDEST piece
            if (currentMoves.length > 3) {
                const oldestPieceId = currentMoves.shift(); // Get the oldest piece ID
                // Find where the oldest piece is on the board and remove it
                const oldestMoveIndex = gameState.indexOf(oldestPieceId);
                if (oldestMoveIndex !== -1) {
                    gameState[oldestMoveIndex] = 0; // Clear the cell in the state
                    const oldestCell = gameCells[oldestMoveIndex];
                    const oldestCellContent = oldestCell.querySelector('.cell-content');
                    oldestCellContent.textContent = "";
                    oldestCellContent.classList.remove('x', 'o');
                }
            }
            
            handleResultValidation();
        }

        function handleResultValidation() {
            let roundWon = checkWin(gameState, currentPlayer);

            if (roundWon) {
                statusDisplay.innerHTML = winningMessage();
                gameActive = false;
                updateTransparencyCue(true);
                return;
            }
        }

        function handlePlayerChange() {
            currentPlayer = currentPlayer === "X" ? "O" : "X";
            statusDisplay.innerHTML = currentPlayerTurn();
            updateTransparencyCue();

            // If it's AI's turn, trigger its move
            if (gameMode === 'pva' && currentPlayer === aiPlayer && gameActive) {
                // Add a small delay for better user experience
                setTimeout(aiMove, 500);
            }
        }

        function updateTransparencyCue(clearAll = false) {
            gameCells.forEach(cell => {
                cell.querySelector('.cell-content').classList.remove('next-to-remove');
            });
            if (clearAll) return;

            const nextPlayerMoves = currentPlayer === 'X' ? playerXMoves : playerOMoves;
            if (nextPlayerMoves.length === 3) {
                const oldestMoveIndex = nextPlayerMoves[0];
                gameCells[oldestMoveIndex].querySelector('.cell-content').classList.add('next-to-remove');
            }
        }

        // --- NEW: AI Move Lookup Table ---
        let precomputedMoves = null;

        // Function to load the JSON data
        async function loadPrecomputedMoves() {
            try {
                const response = await fetch('./tactictoe_states.json'); // Assumes moves.json is in the same folder
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                precomputedMoves = await response.json();
                console.log("AI moves loaded successfully.");
                // You could enable the AI button here if it was initially disabled
            } catch (error) {
                console.error("Could not load AI moves:", error);
                // Maybe disable the Player vs AI button if data fails to load
                pvaButton.disabled = true;
                pvaButton.textContent = "AI Unavailable";
                pvaButton.style.backgroundColor = '#475569'; // slate-600
            }
        }

        // --- Call the function to load data when the script starts ---
        loadPrecomputedMoves();

        // --- NEW: JavaScript implementation of your Python functions ---

        // Player constants (assuming X is 1, O is -1, as often used in AI)
        const X = 1;
        const O = -1;

        // The 8 symmetries of the Tic-Tac-Toe board
        const TRANSFORMATION_MAPS = [
            [0, 1, 2, 3, 4, 5, 6, 7, 8], // Identity
            [2, 5, 8, 1, 4, 7, 0, 3, 6], // Rotate 90
            [8, 7, 6, 5, 4, 3, 2, 1, 0], // Rotate 180
            [6, 3, 0, 7, 4, 1, 8, 5, 2], // Rotate 270
            [2, 1, 0, 5, 4, 3, 8, 7, 6], // Flip horizontal
            [0, 3, 6, 1, 4, 7, 2, 5, 8], // Flip along y=x axis
            [8, 5, 2, 7, 4, 1, 6, 3, 0], // Flip along y=-x axis
            [6, 7, 8, 3, 4, 5, 0, 1, 2], // Flip vertical
        ];

        /**
         * CORRECTED: Translates the board state to a location array based on unique piece IDs.
         * This now matches the Python implementation used to generate the JSON.
         * @param {number[]} board_flat - The 9-element array representing the board (using numbers).
         * @returns {number[]} A 6-element array of piece locations.
         */
        function boardToPosition(board_flat) {
            const CELL_MAP = {
                '-3': 0, '-2': 1, '-1': 2,
                '1': 3,  '2': 4,  '3': 5
            };

            // Initialize with the sentinel value 0x0F (15)
            const location_arr = Array(6).fill(0x0F);
            
            for (let i = 0; i < board_flat.length; i++) {
                const cell = board_flat[i];
                if (cell !== 0) { // If the cell is not empty
                    const pieceId = cell.toString();
                    const locationIndex = CELL_MAP[pieceId];
                    location_arr[locationIndex] = i;
                }
            }
            return location_arr;
        }


        /**
         * Encodes the board state and turn into a single 32-bit integer key.
         * This matches the format of the keys in your Python-generated JSON.
         * @param {number[]} playerXMoves - The indices of X's pieces.
         * @param {number[]} playerOMoves - The indices of O's pieces.
         * @param {number} turn - The current player (1 for X, -1 for O).
         * @returns {number} The integer key representing the game state.
         */
        function encodeState(board_flat, turn) {
            // This is the only function that needs boardToPosition
            const location_arr = boardToPosition(board_flat);

            const byte0 = (location_arr[0] << 4) | location_arr[1];
            const byte1 = (location_arr[2] << 4) | location_arr[3];
            const byte2 = (location_arr[4] << 4) | location_arr[5];
            const byte3 = (turn === X) ? 1 : 0;

            return ((byte0 << 24) | (byte1 << 16) | (byte2 << 8) | byte3) >>> 0;
        }

        /**
         * Decodes a 32-bit integer key back into a game state object.
         * Useful for debugging and verification.
         * @param {number} encoded_state - The integer key.
         * @returns {object} An object containing the board, moves, and turn.
         */
        function decodeState(encoded_state) {
            const byte0 = (encoded_state >> 24) & 0xFF;
            const byte1 = (encoded_state >> 16) & 0xFF;
            const byte2 = (encoded_state >> 8) & 0xFF;
            const byte3 = encoded_state & 0xFF;

            const turn = (byte3 & 0x01) === 1 ? X : O;

            const location_arr = [
                byte0 >> 4,
                byte0 & 0x0F,
                byte1 >> 4,
                byte1 & 0x0F,
                byte2 >> 4,
                byte2 & 0x0F,
            ];
            
            // NEW: Maps the location_arr index back to a unique piece ID
            const CELL_MAP_REV = {
                0: -3, 1: -2, 2: -1,
                3: 1,  4: 2,  5: 3,
            };

            // CORRECTED: Create a numeric board state
            const board_flat = Array(9).fill(0); // Use 0 for empty
            let playerXMoves = [];
            let playerOMoves = [];

            location_arr.forEach((pos, index) => {
                if (pos !== 0x0F) { // If the piece is on the board
                    const pieceId = CELL_MAP_REV[index];
                    board_flat[pos] = pieceId;
                    // Reconstruct the move history for the simulation
                    if (pieceId > 0) {
                        playerXMoves.push(pieceId);
                    } else {
                        playerOMoves.push(pieceId);
                    }
                }
            });

            return {
                board: board_flat,
                playerXMoves: playerXMoves.sort(),
                playerOMoves: playerOMoves.sort((a,b) => a - b),
                turn: turn, // Return numeric turn
            };
        }

        /**
         * CORRECTED: Finds the canonical representation and returns both the key
         * and the transformation map used to achieve it.
         * @param {number[]} board_flat - The 9-element array representing the board.
         * @param {number} turn - The current player (1 or -1).
         * @returns {object} An object containing the { key, transform }.
         */
        function getCanonicalForm(board_flat, turn) {
            let minStateEncoded = encodeState(board_flat, turn);
            let bestTransform = TRANSFORMATION_MAPS[0]; // Start with the identity transform

            for (const transform_map of TRANSFORMATION_MAPS) {
                // Create a new board based on the current transformation
                const transformed_board = Array(9).fill(0);
                for(let i = 0; i < 9; i++) {
                    // Place the piece from the original board (board_flat[i])
                    // into its new, transformed position (transform_map[i])
                    transformed_board[transform_map[i]] = board_flat[i];
                }

                const transformedStateEncoded = encodeState(transformed_board, turn);
                
                if (transformedStateEncoded < minStateEncoded) {
                    minStateEncoded = transformedStateEncoded;
                    bestTransform = transform_map; // Store the transform that gave the best key
                }
            }

            return { key: minStateEncoded, transform: bestTransform };
        }

        // --- AI Logic (Lookup Table) ---

        function aiMove() {
            if (!precomputedMoves) {
                console.log("AI is thinking... (or data is still loading)");
                return;
            }

            // findBestMoveFromJSON now returns a single index or null.
            const bestMoveIndex = findBestMoveFromJSON(); 
            
            if (bestMoveIndex !== null && bestMoveIndex !== -1) {
                // The makeMove function is all we need. It will place the piece
                // and handle removing the oldest one if the player has 3 marks.
                makeMove(bestMoveIndex);

                if (gameActive) {
                    handlePlayerChange();
                }
            } else {
                console.error("AI could not determine a valid move!");
                statusDisplay.innerHTML = "AI is confused!";
                gameActive = false;
            }
        }

        // /**
        //  * Generates all possible moves for a player from the current state.
        //  */
        // function getAvailableMoves(boardState, player) {
        //     const availableMoves = [];
        //     const emptyCells = [];
        //     const playerPieces = [];

        //     // CORRECTED: Find empty cells (0) and the current player's pieces
        //     boardState.forEach((cell, index) => {
        //         if (cell === 0) {
        //             emptyCells.push(index);
        //         } else if ((player === 'X' && cell > 0) || (player === 'O' && cell < 0)) {
        //             playerPieces.push(index);
        //         }
        //     });

        //     if (playerPieces.length < 3) {
        //         // Placement moves: from a non-existent spot (-1) to an empty cell.
        //         emptyCells.forEach(to => {
        //             availableMoves.push([-1, to]);
        //         });
        //     } else {
        //         // Moving pieces: from an existing piece position to an empty cell.
        //         playerPieces.forEach(from => {
        //             emptyCells.forEach(to => {
        //                 availableMoves.push([from, to]);
        //             });
        //         });
        //     }
        //     return availableMoves;
        // }

        // /**
        //  * Simulates a move on a given state and returns the new numeric board state.
        //  */
        // function simulateMove(state, move, pieceIdToPlace) {
        //     const [from, to] = move;
            
        //     const newGameState = [...state.board];
        //     let currentMoves = pieceIdToPlace > 0 ? [...state.playerXMoves] : [...state.playerOMoves];

        //     // Place the new piece
        //     newGameState[to] = pieceIdToPlace;
        //     currentMoves.push(pieceIdToPlace);

        //     // If it was a move, clear the 'from' square
        //     if (from !== -1) {
        //         newGameState[from] = 0;
        //     } 
        //     // If it was a placement that resulted in more than 3 pieces, remove the oldest
        //     else if (currentMoves.length > 3) {
        //         const oldestPieceId = currentMoves.shift();
        //         const oldestIndex = newGameState.indexOf(oldestPieceId);
        //         if (oldestIndex !== -1) {
        //             newGameState[oldestIndex] = 0;
        //         }
        //     }
            
        //     // We only need the resulting board for the canonical key calculation
        //     return { newGameState };
        // }

        /**
         * CORRECTED: Finds the best placement index by mapping the move for the
         * canonical board back to the original board.
         */
        function findBestMoveFromJSON() {
            // 1. Get the canonical key and the transformation used to get there.
            const turn = (currentPlayer === 'X') ? X : O;
            const canonicalData = getCanonicalForm(gameState, turn);
            const { key, transform } = canonicalData;

            const moveData = precomputedMoves[key];
            if (!moveData || moveData.moves.length === 0) {
                console.error("No moves found for canonical key:", key);
                return null;
            }

            // 2. Get the best move from the JSON, which is in [row, col] format.
            const bestCanonicalMove = moveData.moves[Math.floor(Math.random() * moveData.moves.length)];
            const [row, col] = bestCanonicalMove;
            
            // 3. Convert the canonical [row, col] move to a 1D board index (0-8).
            const canonicalMoveIndex = row * 3 + col;

            // 4. Find the corresponding move on the ORIGINAL board.
            // The 'transform' array tells us: new_position = transform[old_position].
            // To reverse this, we find the index where the value matches our target.
            const originalMoveIndex = transform.indexOf(canonicalMoveIndex);

            return originalMoveIndex;
        }

        function checkWin(board, player) {
            const isX = player === 'X';
            for (let i = 0; i < winningConditions.length; i++) {
                const [a, b, c] = winningConditions[i];
                // Check if all three cells belong to the player (positive for X, negative for O)
                const cellA = board[a];
                const cellB = board[b];
                const cellC = board[c];
                if (isX) {
                    if (cellA > 0 && cellB > 0 && cellC > 0) return true;
                } else {
                    if (cellA < 0 && cellB < 0 && cellC < 0) return true;
                }
            }
            return false;
        }

        // --- Event Listeners ---
        pvpButton.addEventListener('click', () => selectGameMode('pvp'));
        pvaButton.addEventListener('click', () => selectGameMode('pva'));
        restartButton.addEventListener('click', handleRestartGame);
        gameCells.forEach(cell => cell.addEventListener('click', handleCellClick));
        // --- NEW EVENT LISTENERS ---
        chooseXButton.addEventListener('click', () => selectPlayerSymbol('X'));
        chooseOButton.addEventListener('click', () => selectPlayerSymbol('O'));

    </script>
</body>
</html>