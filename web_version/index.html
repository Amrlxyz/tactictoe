<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe with AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .cell {
            width: 100%;
            padding-bottom: 100%;
            position: relative;
            transition: background-color 0.3s ease;
        }
        .cell-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            transition: opacity 0.4s ease;
        }
        .cell-content.x { color: #38bdf8; }
        .cell-content.o { color: #fb923c; }
        .cell-content.next-to-remove { opacity: 0.5; }
        .hidden { display: none; }
        .mode-button.selected { background-color: #0ea5e9; }
        @media (min-width: 640px) {
            .cell-content { font-size: 4.5rem; }
        }
    </style>
</head>
<body class="bg-slate-900 text-white flex items-center justify-center min-h-screen p-4">

    <main class="w-full max-w-md mx-auto text-center">
        <h1 class="text-4xl md:text-5xl font-bold mb-2 text-slate-200">Tic-Tac-Toe</h1>
        <p class="text-slate-400 mb-4">3-Mark Limit Edition</p>
        
        <div id="game-mode-selection" class="mb-6">
            <h3 class="text-lg text-slate-300 mb-3">Choose your opponent:</h3>
            <div class="flex justify-center gap-4">
                <button id="pvp-button" class="mode-button bg-sky-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-700 transition-all">Player vs Player</button>
                <button id="pva-button" class="mode-button bg-sky-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-700 transition-all">Player vs AI</button>
            </div>
        </div>

        <div id="player-symbol-selection" class="hidden mb-6">
            <h3 class="text-lg text-slate-300 mb-3">Choose your mark:</h3>
            <div class="flex justify-center gap-4">
                <button id="choose-x-button" class="mode-button bg-sky-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-600 transition-all">Play as X</button>
                <button id="choose-o-button" class="mode-button bg-orange-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-orange-600 transition-all">Play as O</button>
            </div>
        </div>

        <div id="game-area" class="hidden">
            <h2 id="status" class="text-xl md:text-2xl font-medium mb-6 h-8 text-slate-400"></h2>
            <section id="game-board" class="grid grid-cols-3 gap-3 bg-slate-800 p-3 rounded-lg shadow-2xl">
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
                <div class="cell bg-slate-900 rounded-md cursor-pointer hover:bg-slate-700"><div class="cell-content"></div></div>
            </section>
            <button id="restart-button" class="mt-8 bg-rose-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:bg-rose-700 transition-all">Change Mode</button>
        </div>
    </main>

    <script>
        // --- DOM Elements ---
        const statusDisplay = document.getElementById('status');
        const gameCells = document.querySelectorAll('.cell');
        const restartButton = document.getElementById('restart-button');
        const gameModeSelection = document.getElementById('game-mode-selection');
        const pvpButton = document.getElementById('pvp-button');
        const pvaButton = document.getElementById('pva-button');
        const gameArea = document.getElementById('game-area');
        // --- NEW DOM ELEMENTS ---
        const playerSymbolSelection = document.getElementById('player-symbol-selection');
        const chooseXButton = document.getElementById('choose-x-button');
        const chooseOButton = document.getElementById('choose-o-button');


        // --- Game State Variables ---
        let gameActive = false;
        let currentPlayer = 'X';
        let gameState = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        let playerXMoves = [];
        let playerOMoves = [];
        let gameMode = 'pvp'; // 'pvp' or 'pva'
        // --- MODIFIED: Changed from const to let ---
        let humanPlayer = 'X';
        let aiPlayer = 'O';

        // --- Winning Combinations ---
        const winningConditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], 
            [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]
        ];
        
        // --- Messages ---
        const winningMessage = () => `Player ${currentPlayer} has won!`;
        const currentPlayerTurn = () => `Player ${currentPlayer}'s turn`;

        // --- Game Setup Functions ---
        
        // --- This function now handles showing the symbol choice screen ---
        function selectGameMode(mode) {
            gameMode = mode;
            gameModeSelection.classList.add('hidden');
            
            if (mode === 'pvp') {
                gameArea.classList.remove('hidden');
                startGame();
            } else { // 'pva'
                playerSymbolSelection.classList.remove('hidden');
            }
        }

        // --- Handles the player's choice of X or O ---
        function selectPlayerSymbol(symbol) {
            humanPlayer = symbol;
            aiPlayer = symbol === 'X' ? 'O' : 'X';
            
            playerSymbolSelection.classList.add('hidden');
            gameArea.classList.remove('hidden');
            startGame();

            // If human chose 'O', AI ('X') must go first.
            if (currentPlayer === aiPlayer) {
                 setTimeout(aiMove, 500);
            }
        }

        function startGame() {
            gameActive = true;
            currentPlayer = 'X';
            // Initialize with 0 for empty cells
            gameState = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            playerXMoves = [];
            playerOMoves = [];
            statusDisplay.innerHTML = currentPlayerTurn();
            gameCells.forEach(cell => {
                const cellContent = cell.querySelector('.cell-content');
                cellContent.textContent = "";
                cellContent.classList.remove('x', 'o', 'next-to-remove');
            });
        }

        // --- MODIFIED: Now also hides the new symbol selection screen ---
        function handleRestartGame() {
            gameActive = false;
            gameArea.classList.add('hidden');
            playerSymbolSelection.classList.add('hidden'); // Hide symbol choice on restart
            gameModeSelection.classList.remove('hidden');
        }

        // --- Core Game Logic ---

        function handleCellClick(clickedCellEvent) {
            const clickedCell = clickedCellEvent.currentTarget;
            const clickedCellIndex = Array.from(gameCells).indexOf(clickedCell);

            // Prevent move if cell is taken (not 0), game is inactive, or it's AI's turn
            if (gameState[clickedCellIndex] !== 0 || !gameActive || (gameMode === 'pva' && currentPlayer === aiPlayer)) {
                return;
            }

            makeMove(clickedCellIndex);

            if (gameActive) {
                handlePlayerChange();
            }
        }


        function makeMove(index) {
            if (gameState[index] !== 0 || !gameActive) return;

            const isX = currentPlayer === 'X';
            const currentMoves = isX ? playerXMoves : playerOMoves;
            
            if (currentMoves.length < 3) {
                // --- PLACEMENT PHASE ---
                // CORRECTED: A new piece is always placed with the max value.
                const pieceToPlace = isX ? 3 : -3;

                // Update state and UI
                gameState[index] = pieceToPlace;
                currentMoves.push(pieceToPlace);
                
                const cell = gameCells[index];
                const cellContent = cell.querySelector('.cell-content');
                cellContent.textContent = currentPlayer;
                cellContent.classList.add(currentPlayer.toLowerCase());

            } else {
                // --- MOVE PHASE (This part was already correct) ---
                // 1. Identify and remove the oldest piece.
                const pieceToMove = currentMoves.shift();
                
                // 2. Find and clear its old location.
                const fromIndex = gameState.indexOf(pieceToMove);
                if (fromIndex !== -1) {
                    gameState[fromIndex] = 0;
                    const fromCell = gameCells[fromIndex];
                    fromCell.querySelector('.cell-content').textContent = "";
                    fromCell.querySelector('.cell-content').classList.remove('x', 'o');
                }

                // 3. Place that same piece in the new location.
                gameState[index] = pieceToMove;
                const toCell = gameCells[index];
                toCell.querySelector('.cell-content').textContent = currentPlayer;
                toCell.querySelector('.cell-content').classList.add(currentPlayer.toLowerCase());
                
                // 4. Add the piece back to the end of the list, as it's now the newest.
                currentMoves.push(pieceToMove);
            }
            
            handleResultValidation();
        }

        /**
         * Ages all pieces for the specified player on the board.
         * @param {string} player - The player ('X' or 'O') whose pieces will be aged.
         */
        function agePlayerPieces(player) {
            for (let i = 0; i < gameState.length; i++) {
                const piece = gameState[i];
                if (player === 'X' && piece > 0 && piece <= 3) {
                    gameState[i] -= 1; // Positive pieces count down
                } else if (player === 'O' && piece < 0 && piece >= -3) {
                    gameState[i] += 1; // Negative pieces count up (towards 0)
                }
            }
        }

        function handlePlayerChange() {
            // CORRECTED: Age the pieces of the player who just finished their turn.
            agePlayerPieces(currentPlayer);

            // Now, switch the player
            currentPlayer = currentPlayer === "X" ? "O" : "X";
            statusDisplay.innerHTML = currentPlayerTurn();
            updateTransparencyCue();

            // If it's AI's turn, trigger its move
            if (gameMode === 'pva' && currentPlayer === aiPlayer && gameActive) {
                setTimeout(aiMove, 500);
            }
        }


        function handleResultValidation() {
            let roundWon = checkWin(gameState, currentPlayer);

            if (roundWon) {
                statusDisplay.innerHTML = winningMessage();
                gameActive = false;
                updateTransparencyCue(true);
                return;
            }
        }

        function updateTransparencyCue(clearAll = false) {
            gameCells.forEach(cell => {
                cell.querySelector('.cell-content').classList.remove('next-to-remove');
            });
            if (clearAll) return;

            const nextPlayerMoves = currentPlayer === 'X' ? playerXMoves : playerOMoves;
            
            // Check if the NEXT player will be in the "move phase"
            if (nextPlayerMoves.length === 3) {
                // CORRECTED: Find the board index of the oldest piece instead of using the piece ID as an index.
                const oldestPieceId = nextPlayerMoves[0]; // Get the ID of the oldest piece
                const oldestMoveIndex = gameState.indexOf(oldestPieceId); // Find its actual position on the board
                
                if (oldestMoveIndex !== -1) {
                    gameCells[oldestMoveIndex].querySelector('.cell-content').classList.add('next-to-remove');
                }
            }
        }

        // --- AI Move Lookup Table ---
        let precomputedMoves = null;

        // Function to load the JSON data
        async function loadPrecomputedMoves() {
            try {
                const response = await fetch('./tactictoe_states.json'); // Assumes moves.json is in the same folder
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                precomputedMoves = await response.json();
                console.log("AI moves loaded successfully.");
                // You could enable the AI button here if it was initially disabled
            } catch (error) {
                console.error("Could not load AI moves:", error);
                // Maybe disable the Player vs AI button if data fails to load
                pvaButton.disabled = true;
                pvaButton.textContent = "AI Unavailable";
                pvaButton.style.backgroundColor = '#475569'; // slate-600
            }
        }

        // --- Call the function to load data when the script starts ---
        loadPrecomputedMoves();

        // --- NEW: JavaScript implementation of your Python functions ---

        // Player constants (assuming X is 1, O is -1, as often used in AI)
        const X = 1;
        const O = -1;

        // The 8 symmetries of the Tic-Tac-Toe board
        const TRANSFORMATION_MAPS = [
            [0, 1, 2, 3, 4, 5, 6, 7, 8], // Identity
            [2, 5, 8, 1, 4, 7, 0, 3, 6], // Rotate 90
            [8, 7, 6, 5, 4, 3, 2, 1, 0], // Rotate 180
            [6, 3, 0, 7, 4, 1, 8, 5, 2], // Rotate 270
            [2, 1, 0, 5, 4, 3, 8, 7, 6], // Flip horizontal
            [0, 3, 6, 1, 4, 7, 2, 5, 8], // Flip along y=x axis
            [8, 5, 2, 7, 4, 1, 6, 3, 0], // Flip along y=-x axis
            [6, 7, 8, 3, 4, 5, 0, 1, 2], // Flip vertical
        ];

        /**
         * CORRECTED: Translates the board state to a location array based on unique piece IDs.
         * This now matches the Python implementation used to generate the JSON.
         * @param {number[]} board_flat - The 9-element array representing the board (using numbers).
         * @returns {number[]} A 6-element array of piece locations.
         */
        function boardToPosition(board_flat) {
            const CELL_MAP = {
                '-3': 0, '-2': 1, '-1': 2,
                '1': 3,  '2': 4,  '3': 5
            };

            // Initialize with the sentinel value 0x0F (15)
            const location_arr = Array(6).fill(0x0F);
            
            for (let i = 0; i < board_flat.length; i++) {
                const cell = board_flat[i];
                if (cell !== 0) { // If the cell is not empty
                    const pieceId = cell.toString();
                    const locationIndex = CELL_MAP[pieceId];
                    location_arr[locationIndex] = i;
                }
            }
            return location_arr;
        }


        /**
         * Encodes the board state and turn into a single 32-bit integer key.
         * This matches the format of the keys in your Python-generated JSON.
         * @param {number[]} playerXMoves - The indices of X's pieces.
         * @param {number[]} playerOMoves - The indices of O's pieces.
         * @param {number} turn - The current player (1 for X, -1 for O).
         * @returns {number} The integer key representing the game state.
         */
        function encodeState(board_flat, turn) {
            // This is the only function that needs boardToPosition
            const location_arr = boardToPosition(board_flat);

            const byte0 = (location_arr[0] << 4) | location_arr[1];
            const byte1 = (location_arr[2] << 4) | location_arr[3];
            const byte2 = (location_arr[4] << 4) | location_arr[5];
            const byte3 = (turn === X) ? 1 : 0;

            return ((byte0 << 24) | (byte1 << 16) | (byte2 << 8) | byte3) >>> 0;
        }

        /**
         * Decodes a 32-bit integer key back into a game state object.
         * Useful for debugging and verification.
         * @param {number} encoded_state - The integer key.
         * @returns {object} An object containing the board, moves, and turn.
         */
        function decodeState(encoded_state) {
            const byte0 = (encoded_state >> 24) & 0xFF;
            const byte1 = (encoded_state >> 16) & 0xFF;
            const byte2 = (encoded_state >> 8) & 0xFF;
            const byte3 = encoded_state & 0xFF;

            const turn = (byte3 & 0x01) === 1 ? X : O;

            const location_arr = [
                byte0 >> 4,
                byte0 & 0x0F,
                byte1 >> 4,
                byte1 & 0x0F,
                byte2 >> 4,
                byte2 & 0x0F,
            ];
            
            // NEW: Maps the location_arr index back to a unique piece ID
            const CELL_MAP_REV = {
                0: -3, 1: -2, 2: -1,
                3: 1,  4: 2,  5: 3,
            };

            // CORRECTED: Create a numeric board state
            const board_flat = Array(9).fill(0); // Use 0 for empty
            let playerXMoves = [];
            let playerOMoves = [];

            location_arr.forEach((pos, index) => {
                if (pos !== 0x0F) { // If the piece is on the board
                    const pieceId = CELL_MAP_REV[index];
                    board_flat[pos] = pieceId;
                    // Reconstruct the move history for the simulation
                    if (pieceId > 0) {
                        playerXMoves.push(pieceId);
                    } else {
                        playerOMoves.push(pieceId);
                    }
                }
            });

            return {
                board: board_flat,
                playerXMoves: playerXMoves.sort(),
                playerOMoves: playerOMoves.sort((a,b) => a - b),
                turn: turn, // Return numeric turn
            };
        }

        /**
         * CORRECTED: Finds the canonical representation and returns both the key
         * and the transformation map used to achieve it.
         * @param {number[]} board_flat - The 9-element array representing the board.
         * @param {number} turn - The current player (1 or -1).
         * @returns {object} An object containing the { key, transform }.
         */
        function getCanonicalForm(board_flat, turn) {
            let minStateEncoded = encodeState(board_flat, turn);
            let bestTransform = TRANSFORMATION_MAPS[0]; // Start with the identity transform

            for (const transform_map of TRANSFORMATION_MAPS) {
                // Create a new board based on the current transformation
                const transformed_board = Array(9).fill(0);
                for(let i = 0; i < 9; i++) {
                    // Place the piece from the original board (board_flat[i])
                    // into its new, transformed position (transform_map[i])
                    transformed_board[transform_map[i]] = board_flat[i];
                }

                const transformedStateEncoded = encodeState(transformed_board, turn);
                
                if (transformedStateEncoded < minStateEncoded) {
                    minStateEncoded = transformedStateEncoded;
                    bestTransform = transform_map; // Store the transform that gave the best key
                }
            }

            return { key: minStateEncoded, transform: bestTransform };
        }

        // --- AI Logic (Lookup Table) ---

        function aiMove() {
            if (!precomputedMoves) {
                console.log("AI is thinking... (or data is still loading)");
                return;
            }

            // findBestMoveFromJSON now returns a single index or null.
            const bestMoveIndex = findBestMoveFromJSON(); 
            
            if (bestMoveIndex !== null && bestMoveIndex !== -1) {
                // The makeMove function is all we need. It will place the piece
                // and handle removing the oldest one if the player has 3 marks.
                makeMove(bestMoveIndex);

                if (gameActive) {
                    handlePlayerChange();
                }
            } else {
                console.error("AI could not determine a valid move!");
                statusDisplay.innerHTML = "AI is confused!";
                gameActive = false;
            }
        }

        /**
         * Generates all possible moves for a player from the current state.
         * A move is represented as a [from, to] pair.
         * For placements, 'from' is -1. For movements, 'from' is the piece's board index.
         * @param {number[]} boardState - The 9-element array of the board (using numbers).
         * @param {string} player - The current player ('X' or 'O').
         * @returns {number[][]} An array of all possible moves, e.g., [[-1, 0], [2, 5]].
         */
        function getAvailableMoves(boardState, player) {
            const availableMoves = [];
            const emptyCells = [];
            const playerPieceLocations = [];

            // Find all empty cells and the locations of the current player's pieces
            boardState.forEach((cell, index) => {
                if (cell === 0) {
                    emptyCells.push(index);
                } else if ((player === 'X' && cell > 0) || (player === 'O' && cell < 0)) {
                    playerPieceLocations.push(index);
                }
            });

            if (playerPieceLocations.length < 3) {
                // --- Placement Phase ---
                // Moves are from a non-existent spot (-1) to any empty cell.
                emptyCells.forEach(to => {
                    availableMoves.push([-1, to]);
                });
            } else {
                // --- Move Phase ---
                // Moves are from an existing piece's location to any empty cell.
                playerPieceLocations.forEach(from => {
                    emptyCells.forEach(to => {
                        availableMoves.push([from, to]);
                    });
                });
            }
            return availableMoves;
        }


        /**
         * Simulates a move on a given state and returns the new state object.
         * This function does NOT handle the "aging" of pieces.
         * @param {object} state - The current state { board, playerXMoves, playerOMoves, turn }.
         * @param {number[]} move - The move to simulate [from, to].
         * @param {number} pieceIdToPlace - The piece ID for a NEW placement (typically 3 or -3).
         * @returns {object} The new state after the move: { newGameState, newPlayerXMoves, newPlayerOMoves }.
         */
        function simulateMove(state, move, pieceIdToPlace) {
            const [from, to] = move;

            // Create copies to work with to avoid changing the original state
            const newGameState = [...state.board];
            const newPlayerXMoves = [...state.playerXMoves];
            const newPlayerOMoves = [...state.playerOMoves];

            // Determine which player is moving from the state object
            const isX = state.turn === X;
            const currentSimMoves = isX ? newPlayerXMoves : newPlayerOMoves;

            if (from === -1) {
                // --- This is a PLACEMENT SIMULATION ---
                newGameState[to] = pieceIdToPlace;
                currentSimMoves.push(pieceIdToPlace);

            } else {
                // --- This is a MOVE SIMULATION ---
                // Find the piece that is being moved
                const pieceToMove = newGameState[from];
                
                // Clear its old spot on the board
                newGameState[from] = 0;
                
                // Place it in the new spot
                newGameState[to] = pieceToMove;
                
                // Update the move history by moving the piece ID to the end, making it the newest
                const pieceIndexInHistory = currentSimMoves.indexOf(pieceToMove);
                if (pieceIndexInHistory > -1) {
                    currentSimMoves.splice(pieceIndexInHistory, 1);
                }
                currentSimMoves.push(pieceToMove);
            }

            return { newGameState, newPlayerXMoves, newPlayerOMoves };
        }

        /**
         * Simulates the aging process on a given board state without modifying the original.
         * @param {number[]} board - The board state to process.
         * @param {string} player - The player ('X' or 'O') whose pieces will be aged.
         * @returns {number[]} The new board state after aging.
         */
        function getAgedSimulatedBoard(board, player) {
            const agedBoard = [...board];
            for (let i = 0; i < agedBoard.length; i++) {
                const piece = agedBoard[i];
                if (player === 'X' && piece > 0 && piece <= 3) {
                    agedBoard[i] -= 1;
                } else if (player === 'O' && piece < 0 && piece >= -3) {
                    agedBoard[i] += 1;
                }
            }
            return agedBoard;
        }

        function findBestMoveFromJSON() {
            const turn = (currentPlayer === 'X') ? X : O;
            const canonicalData = getCanonicalForm(gameState, turn);
            const { key } = canonicalData;

            const moveData = precomputedMoves[key];
            if (!moveData || moveData.moves.length === 0) {
                console.error("No moves found for canonical key:", key); return null;
            }

            // Get the best move from JSON, which is in [row, col] format
            const bestCanonicalMove_RowCol = moveData.moves[Math.floor(Math.random() * moveData.moves.length)];
            
            // --- START OF CORRECTION ---
            // CONVERT [row, col] into the [from, to] format our engine uses
            const [row, col] = bestCanonicalMove_RowCol;
            const to_index = row * 3 + col;
            const bestCanonicalMove_FromTo = [-1, to_index]; // All moves from JSON are placements
            // --- END OF CORRECTION ---

            const canonicalStateDecoded = decodeState(key);
            
            // Use the converted move for the simulation
            const stateAfterMove = simulateMove(canonicalStateDecoded, bestCanonicalMove_FromTo, (turn === X ? 3 : -3));
            const agedBoard = getAgedSimulatedBoard(stateAfterMove.newGameState, (turn === X ? 'X' : 'O'));
            const targetCanonicalKey = getCanonicalForm(agedBoard, (turn === X ? O : X)).key;

            const availableMoves = getAvailableMoves(gameState, currentPlayer);
            const validBestMoves = [];

            for (const move of availableMoves) {
                const stateAfterRealMove = simulateMove({board: gameState, playerXMoves, playerOMoves, turn: turn}, move, (currentPlayer === 'X' ? 3 : -3));
                const agedRealBoard = getAgedSimulatedBoard(stateAfterRealMove.newGameState, currentPlayer);
                const resultingKey = getCanonicalForm(agedRealBoard, (turn === X ? O : X)).key;

                if (resultingKey === targetCanonicalKey) {
                    validBestMoves.push(move);
                }
            }

            if (validBestMoves.length > 0) {
                return validBestMoves[Math.floor(Math.random() * validBestMoves.length)];
            }

            console.error("Could not find a valid original move that maps to the canonical best move.");
            return null;
        }

        function checkWin(board, player) {
            const isX = player === 'X';
            for (let i = 0; i < winningConditions.length; i++) {
                const [a, b, c] = winningConditions[i];
                // Check if all three cells belong to the player (positive for X, negative for O)
                const cellA = board[a];
                const cellB = board[b];
                const cellC = board[c];
                if (isX) {
                    if (cellA > 0 && cellB > 0 && cellC > 0) return true;
                } else {
                    if (cellA < 0 && cellB < 0 && cellC < 0) return true;
                }
            }
            return false;
        }

        // --- Event Listeners ---
        pvpButton.addEventListener('click', () => selectGameMode('pvp'));
        pvaButton.addEventListener('click', () => selectGameMode('pva'));
        restartButton.addEventListener('click', handleRestartGame);
        gameCells.forEach(cell => cell.addEventListener('click', handleCellClick));
        // --- NEW EVENT LISTENERS ---
        chooseXButton.addEventListener('click', () => selectPlayerSymbol('X'));
        chooseOButton.addEventListener('click', () => selectPlayerSymbol('O'));

    </script>
</body>
</html>